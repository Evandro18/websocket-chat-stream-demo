{"mappings":"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","sources":["src/index.js"],"sourcesContent":["const recordButton = document.getElementById(\"recordButton\");\nlet isRecording = false;\nlet audioStream;\nlet mediaRecorder;\nlet webSocket;\nlet audioContext;\nlet source;\n/**\n * Audio buffer queue\n * @type {Int16Array[]}\n */\nlet audioBufferQueue = [];\n\nlet audioContextIn;\nlet audioContextOut;\nlet nextBufferTime = 0;\n\nlet fullAudio = [];\n\nfunction convertFloat32ToInt16(sample) {\n  return Math.max(-32768, Math.min(32767, sample * 32767));\n}\n\nfunction startAudioCapture(ws) {\n  navigator.mediaDevices\n    .getUserMedia({\n      audio: {\n        echoCancellation: true,\n        noiseSuppression: true,\n        sampleRate: 16000,\n      },\n    })\n    .then((stream) => {\n      const source = audioContextIn.createMediaStreamSource(stream);\n      const processor = audioContextIn.createScriptProcessor(1024, 1, 1);\n      source.connect(processor);\n      processor.connect(audioContextIn.destination);\n\n      processor.onaudioprocess = (e) => {\n        const inputData = e.inputBuffer.getChannelData(0);\n        const outputData = new Int16Array(inputData.length);\n\n        for (let i = 0; i < inputData.length; i++) {\n          outputData[i] = convertFloat32ToInt16(inputData[i]);\n        }\n\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(outputData.buffer);\n        }\n      };\n\n    })\n    .catch((error) => {\n      console.error(\"getUserMedia error:\", error);\n    });\n  // Initialize WebSocket\n}\n\nasync function startRecording() {\n  try {\n    const inputUrl = document.querySelector(\"#wsUrl\")?.value\n    const inputLanguage = document.querySelector(\"#language\")?.value\n    // const authorization = document.querySelector(\"#authToken\")?.value\n    const authorization = ''\n    webSocket = new WebSocket(`${inputUrl}?language=${inputLanguage}`);\n    isRecording = true;\n    recordButton.textContent = \"Stop Recording\";\n    webSocket.onopen = async () => {\n      msg = { type: \"choose_sale_chat_type\", value: '' }\n      webSocket.send(JSON.stringify(msg));\n\n      startAudioCapture(webSocket);\n    };\n    webSocket.onerror = (error) => {\n      stopRecording();\n      console.error(\"WebSocket error:\", error)\n    };\n    webSocket.onclose = () => {\n      stopRecording();\n      console.log(\"WebSocket connection closed\")\n    };\n\n    webSocket.onmessage = async (event) => {\n      if (event.data instanceof Blob) {\n        const reader = new FileReader();\n        reader.onload = async () => {\n          const arrayBuffer = reader.result;\n          const audioData = new Int16Array(arrayBuffer);\n\n          // Update the latest buffer size\n          latestBufferSize = audioData.byteLength;\n\n          if (audioData.length > 0) {\n            try {\n              await navigator.locks.request(\"audio-playback\", async () => {\n                await playAudio(audioData);\n              });\n            } catch (error) {\n              console.error(\"Error playing audio:\", error);\n            }\n          } else {\n            console.log(\"Received empty audio data after conversion\");\n          }\n        };\n\n        reader.readAsArrayBuffer(event.data);\n      } else {\n        console.log(event.data);\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting recording:\", error);\n  }\n}\n\nfunction stopRecording() {\n  if (mediaRecorder) mediaRecorder.stop();\n  if (audioStream) audioStream.getTracks().forEach((track) => track.stop());\n  if (webSocket) {\n    console.log(\"Closing web socket\");\n    webSocket.close();\n  }\n  isRecording = false;\n  recordButton.textContent = \"Start Recording\";\n}\n\nasync function playAudio(int16Array) {\n  const float32Array = new Float32Array(int16Array.length);\n  for (let i = 0; i < int16Array.length; i++) {\n    float32Array[i] = int16Array[i] / 32768.0;\n  }\n  const audioBuffer = audioContextOut.createBuffer(\n    1,\n    float32Array.length,\n    24000\n  );\n  audioBuffer.getChannelData(0).set(float32Array);\n\n  const source = audioContextOut.createBufferSource();\n  source.buffer = audioBuffer;\n  source.connect(audioContextOut.destination);\n\n  const bufferDuration = audioBuffer.length / audioBuffer.sampleRate;\n  if (nextBufferTime < audioContextOut.currentTime) {\n    nextBufferTime = audioContextOut.currentTime;\n  }\n\n  source.start(nextBufferTime);\n\n  nextBufferTime += bufferDuration;\n  console.log(\"Next buffer time:\", nextBufferTime);\n}\n\n// function playAudio(audioData) {\n//   if (!audioContext) audioContext = new AudioContext();\n\n//   audioContext.decodeAudioData(audioData.slice(0), (buffer) => {\n//     audioBufferQueue.push(buffer);\n//     if (audioBufferQueue.length === 1) {\n//       playNextBuffer();\n//     }\n//   });\n// }\n\nfunction playNextBuffer() {\n  if (audioBufferQueue.length === 0) return;\n\n  const buffer = audioBufferQueue.shift();\n  source = audioContext.createBufferSource();\n  source.buffer = buffer;\n  source.connect(audioContext.destination);\n  source.onended = playNextBuffer;\n  source.start();\n}\n\n/**\n * \n * @param {SubmitEvent} ev \n * @returns \n */\nfunction submit(ev) {\n  ev.preventDefault()  // to stop the form submitting\n  if (isRecording) {\n    stopRecording();\n  } else {\n    startRecording();\n  }\n\n  if (!audioContextIn) {\n    audioContextIn = new AudioContext({ sampleRate: 16000 });\n    audioContextOut = new AudioContext({ sampleRate: 24000 });\n  } else if (audioContextIn.state === \"suspended\") {\n    audioContextIn.resume();\n  }\n  nextBufferTime = audioContextOut.currentTime;\n  return false;\n};\n\ndocument.querySelector('form').onsubmit = submit;\n\nlet recordingActive = false;\nlet buffer = new Uint8Array();\n\nfunction combineArray(newData) {\n  const newBuffer = new Uint8Array(buffer.length + newData.length);\n  newBuffer.set(buffer);\n  newBuffer.set(newData, buffer.length);\n  buffer = newBuffer;\n}\n\nfunction processAudioRecordingBuffer(data) {\n  const uint8Array = new Uint8Array(data);\n  combineArray(uint8Array);\n  bufferSize = 4800;\n  if (buffer.length >= bufferSize) {\n    const toSend = new Uint8Array(buffer.slice(0, bufferSize));\n    buffer = new Uint8Array(buffer.slice(bufferSize));\n    const regularArray = String.fromCharCode(...toSend);\n    const base64 = btoa(regularArray);\n    return base64;\n  }\n}\n"],"names":[],"version":3,"file":"index.579125c3.js.map","sourceRoot":"/__parcel_source_root/"}