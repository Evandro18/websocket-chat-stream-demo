{"mappings":"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","sources":["<anon>","src/index.js"],"sourcesContent":["const recordButton = document.getElementById(\"recordButton\");\nlet isRecording = false;\nlet audioStream;\nlet mediaRecorder;\nlet webSocket;\nlet audioContext;\nlet source;\nlet audioBufferQueue = [];\nlet audioContextIn;\nlet audioContextOut;\nlet nextBufferTime = 0;\nfunction convertFloat32ToInt16(sample) {\n    return Math.max(-32768, Math.min(32767, sample * 32767));\n}\nfunction startAudioCapture(ws) {\n    navigator.mediaDevices.getUserMedia({\n        audio: {\n            echoCancellation: true,\n            noiseSuppression: true,\n            sampleRate: 16000\n        }\n    }).then((stream)=>{\n        const source = audioContextIn.createMediaStreamSource(stream);\n        const processor = audioContextIn.createScriptProcessor(1024, 1, 1);\n        source.connect(processor);\n        processor.connect(audioContextIn.destination);\n        processor.onaudioprocess = (e)=>{\n            const inputData = e.inputBuffer.getChannelData(0);\n            const outputData = new Int16Array(inputData.length);\n            for(let i = 0; i < inputData.length; i++)outputData[i] = convertFloat32ToInt16(inputData[i]);\n            if (ws.readyState === WebSocket.OPEN) ws.send(outputData.buffer);\n        };\n    }).catch((error)=>{\n        console.error(\"getUserMedia error:\", error);\n    });\n// Initialize WebSocket\n}\nasync function startRecording() {\n    try {\n        const inputUrl = document.querySelector(\"#wsUrl\")?.value;\n        // const authorization = document.querySelector(\"#authToken\")?.value\n        const authorization = \"\";\n        webSocket = new WebSocket(`${inputUrl}?language=en-US`);\n        isRecording = true;\n        recordButton.textContent = \"Stop Recording\";\n        webSocket.onopen = async ()=>{\n            const prompt = document.querySelector(\"#llmPrompt\").value;\n            msgPrompt = {\n                type: \"prompt\",\n                value: prompt\n            };\n            webSocket.send(JSON.stringify(msgPrompt));\n            startAudioCapture(webSocket);\n        };\n        webSocket.onerror = (error)=>{\n            stopRecording();\n            console.error(\"WebSocket error:\", error);\n        };\n        webSocket.onclose = ()=>{\n            stopRecording();\n            console.log(\"WebSocket connection closed\");\n        };\n        webSocket.onmessage = async (event)=>{\n            if (event.data instanceof Blob) {\n                const reader = new FileReader();\n                reader.onload = async ()=>{\n                    const arrayBuffer = reader.result;\n                    const audioData = new Int16Array(arrayBuffer);\n                    // Update the latest buffer size\n                    latestBufferSize = audioData.byteLength;\n                    if (audioData.length > 0) try {\n                        await navigator.locks.request(\"audio-playback\", async ()=>{\n                            await playAudio(audioData);\n                        });\n                    } catch (error) {\n                        console.error(\"Error playing audio:\", error);\n                    }\n                    else console.log(\"Received empty audio data after conversion\");\n                };\n                reader.readAsArrayBuffer(event.data);\n            } else console.log(event.data);\n        };\n    } catch (error) {\n        console.error(\"Error starting recording:\", error);\n    }\n}\nfunction stopRecording() {\n    if (mediaRecorder) mediaRecorder.stop();\n    if (audioStream) audioStream.getTracks().forEach((track)=>track.stop());\n    if (webSocket) {\n        console.log(\"Closing web socket\");\n        webSocket.close();\n    }\n    isRecording = false;\n    recordButton.textContent = \"Start Recording\";\n}\nasync function playAudio(int16Array) {\n    const float32Array = new Float32Array(int16Array.length);\n    for(let i = 0; i < int16Array.length; i++)float32Array[i] = int16Array[i] / 32768.0;\n    const audioBuffer = audioContextOut.createBuffer(1, float32Array.length, 24000);\n    audioBuffer.getChannelData(0).set(float32Array);\n    const source = audioContextOut.createBufferSource();\n    source.buffer = audioBuffer;\n    source.connect(audioContextOut.destination);\n    const bufferDuration = audioBuffer.length / audioBuffer.sampleRate;\n    if (nextBufferTime < audioContextOut.currentTime) nextBufferTime = audioContextOut.currentTime;\n    source.start(nextBufferTime);\n    nextBufferTime += bufferDuration;\n    console.log(\"Next buffer time:\", nextBufferTime);\n}\n// function playAudio(audioData) {\n//   if (!audioContext) audioContext = new AudioContext();\n//   audioContext.decodeAudioData(audioData.slice(0), (buffer) => {\n//     audioBufferQueue.push(buffer);\n//     if (audioBufferQueue.length === 1) {\n//       playNextBuffer();\n//     }\n//   });\n// }\nfunction playNextBuffer() {\n    if (audioBufferQueue.length === 0) return;\n    const buffer = audioBufferQueue.shift();\n    source = audioContext.createBufferSource();\n    source.buffer = buffer;\n    source.connect(audioContext.destination);\n    source.onended = playNextBuffer;\n    source.start();\n}\n/**\n * \n * @param {SubmitEvent} ev \n * @returns \n */ function submit(ev) {\n    ev.preventDefault() // to stop the form submitting\n    ;\n    if (isRecording) stopRecording();\n    else startRecording();\n    if (!audioContextIn) {\n        audioContextIn = new AudioContext({\n            sampleRate: 16000\n        });\n        audioContextOut = new AudioContext({\n            sampleRate: 24000\n        });\n    } else if (audioContextIn.state === \"suspended\") audioContextIn.resume();\n    nextBufferTime = audioContextOut.currentTime;\n    return false;\n}\ndocument.querySelector(\"form\").onsubmit = submit;\nlet recordingActive = false;\nlet buffer = new Uint8Array();\nfunction combineArray(newData) {\n    const newBuffer = new Uint8Array(buffer.length + newData.length);\n    newBuffer.set(buffer);\n    newBuffer.set(newData, buffer.length);\n    buffer = newBuffer;\n}\nfunction processAudioRecordingBuffer(data) {\n    const uint8Array = new Uint8Array(data);\n    combineArray(uint8Array);\n    bufferSize = 4800;\n    if (buffer.length >= bufferSize) {\n        const toSend = new Uint8Array(buffer.slice(0, bufferSize));\n        buffer = new Uint8Array(buffer.slice(bufferSize));\n        const regularArray = String.fromCharCode(...toSend);\n        const base64 = btoa(regularArray);\n        return base64;\n    }\n}\n\n//# sourceMappingURL=index.44203d75.js.map\n","const recordButton = document.getElementById(\"recordButton\");\nlet isRecording = false;\nlet audioStream;\nlet mediaRecorder;\nlet webSocket;\nlet audioContext;\nlet source;\nlet audioBufferQueue = [];\n\nlet audioContextIn;\nlet audioContextOut;\nlet nextBufferTime = 0;\n\nfunction convertFloat32ToInt16(sample) {\n  return Math.max(-32768, Math.min(32767, sample * 32767));\n}\n\nfunction startAudioCapture(ws) {\n  navigator.mediaDevices\n    .getUserMedia({\n      audio: {\n        echoCancellation: true,\n        noiseSuppression: true,\n        sampleRate: 16000,\n      },\n    })\n    .then((stream) => {\n      const source = audioContextIn.createMediaStreamSource(stream);\n      const processor = audioContextIn.createScriptProcessor(1024, 1, 1);\n      source.connect(processor);\n      processor.connect(audioContextIn.destination);\n\n      processor.onaudioprocess = (e) => {\n        const inputData = e.inputBuffer.getChannelData(0);\n        const outputData = new Int16Array(inputData.length);\n\n        for (let i = 0; i < inputData.length; i++) {\n          outputData[i] = convertFloat32ToInt16(inputData[i]);\n        }\n\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(outputData.buffer);\n        }\n      };\n\n    })\n    .catch((error) => {\n      console.error(\"getUserMedia error:\", error);\n    });\n  // Initialize WebSocket\n}\n\nasync function startRecording() {\n  try {\n    const inputUrl = document.querySelector(\"#wsUrl\")?.value\n    // const authorization = document.querySelector(\"#authToken\")?.value\n    const authorization = ''\n    webSocket = new WebSocket(`${inputUrl}?language=en-US`);\n    isRecording = true;\n    recordButton.textContent = \"Stop Recording\";\n    webSocket.onopen = async () => {\n      const prompt = document.querySelector(\"#llmPrompt\").value\n      msgPrompt = { type: \"prompt\", value: prompt }\n      webSocket.send(JSON.stringify(msgPrompt));\n\n      startAudioCapture(webSocket);\n    };\n    webSocket.onerror = (error) => {\n      stopRecording();\n      console.error(\"WebSocket error:\", error)\n    };\n    webSocket.onclose = () => {\n      stopRecording();\n      console.log(\"WebSocket connection closed\")\n    };\n\n    webSocket.onmessage = async (event) => {\n      if (event.data instanceof Blob) {\n        const reader = new FileReader();\n        reader.onload = async () => {\n          const arrayBuffer = reader.result;\n          const audioData = new Int16Array(arrayBuffer);\n\n          // Update the latest buffer size\n          latestBufferSize = audioData.byteLength;\n\n          if (audioData.length > 0) {\n            try {\n              await navigator.locks.request(\"audio-playback\", async () => {\n                await playAudio(audioData);\n              });\n            } catch (error) {\n              console.error(\"Error playing audio:\", error);\n            }\n          } else {\n            console.log(\"Received empty audio data after conversion\");\n          }\n        };\n\n        reader.readAsArrayBuffer(event.data);\n      } else {\n        console.log(event.data);\n      }\n    };\n  } catch (error) {\n    console.error(\"Error starting recording:\", error);\n  }\n}\n\nfunction stopRecording() {\n  if (mediaRecorder) mediaRecorder.stop();\n  if (audioStream) audioStream.getTracks().forEach((track) => track.stop());\n  if (webSocket) {\n    console.log(\"Closing web socket\");\n    webSocket.close();\n  }\n  isRecording = false;\n  recordButton.textContent = \"Start Recording\";\n}\n\nasync function playAudio(int16Array) {\n  const float32Array = new Float32Array(int16Array.length);\n  for (let i = 0; i < int16Array.length; i++) {\n    float32Array[i] = int16Array[i] / 32768.0;\n  }\n  const audioBuffer = audioContextOut.createBuffer(\n    1,\n    float32Array.length,\n    24000\n  );\n  audioBuffer.getChannelData(0).set(float32Array);\n\n  const source = audioContextOut.createBufferSource();\n  source.buffer = audioBuffer;\n  source.connect(audioContextOut.destination);\n\n  const bufferDuration = audioBuffer.length / audioBuffer.sampleRate;\n  if (nextBufferTime < audioContextOut.currentTime) {\n    nextBufferTime = audioContextOut.currentTime;\n  }\n\n  source.start(nextBufferTime);\n\n  nextBufferTime += bufferDuration;\n  console.log(\"Next buffer time:\", nextBufferTime);\n}\n\n// function playAudio(audioData) {\n//   if (!audioContext) audioContext = new AudioContext();\n\n//   audioContext.decodeAudioData(audioData.slice(0), (buffer) => {\n//     audioBufferQueue.push(buffer);\n//     if (audioBufferQueue.length === 1) {\n//       playNextBuffer();\n//     }\n//   });\n// }\n\nfunction playNextBuffer() {\n  if (audioBufferQueue.length === 0) return;\n\n  const buffer = audioBufferQueue.shift();\n  source = audioContext.createBufferSource();\n  source.buffer = buffer;\n  source.connect(audioContext.destination);\n  source.onended = playNextBuffer;\n  source.start();\n}\n\n/**\n * \n * @param {SubmitEvent} ev \n * @returns \n */\nfunction submit(ev) {\n  ev.preventDefault()  // to stop the form submitting\n  if (isRecording) {\n    stopRecording();\n  } else {\n    startRecording();\n  }\n\n  if (!audioContextIn) {\n    audioContextIn = new AudioContext({ sampleRate: 16000 });\n    audioContextOut = new AudioContext({ sampleRate: 24000 });\n  } else if (audioContextIn.state === \"suspended\") {\n    audioContextIn.resume();\n  }\n  nextBufferTime = audioContextOut.currentTime;\n  return false;\n};\n\ndocument.querySelector('form').onsubmit = submit;\n\nlet recordingActive = false;\nlet buffer = new Uint8Array();\n\nfunction combineArray(newData) {\n  const newBuffer = new Uint8Array(buffer.length + newData.length);\n  newBuffer.set(buffer);\n  newBuffer.set(newData, buffer.length);\n  buffer = newBuffer;\n}\n\nfunction processAudioRecordingBuffer(data) {\n  const uint8Array = new Uint8Array(data);\n  combineArray(uint8Array);\n  bufferSize = 4800;\n  if (buffer.length >= bufferSize) {\n    const toSend = new Uint8Array(buffer.slice(0, bufferSize));\n    buffer = new Uint8Array(buffer.slice(bufferSize));\n    const regularArray = String.fromCharCode(...toSend);\n    const base64 = btoa(regularArray);\n    return base64;\n  }\n}\n"],"names":["audioStream","mediaRecorder","webSocket","audioContextIn","audioContextOut","recordButton","document","getElementById","isRecording","nextBufferTime","startRecording","inputUrl","querySelector","value","WebSocket","textContent","onopen","prompt","msgPrompt","type","send","JSON","stringify","startAudioCapture","ws","navigator","mediaDevices","getUserMedia","audio","echoCancellation","noiseSuppression","sampleRate","then","stream","source","createMediaStreamSource","processor","createScriptProcessor","connect","destination","onaudioprocess","e","inputData","inputBuffer","getChannelData","outputData","Int16Array","length","i","Math","max","min","sample","readyState","OPEN","buffer","catch","error","console","onerror","stopRecording","onclose","log","onmessage","event","data","Blob","reader","FileReader","onload","arrayBuffer","result","audioData","latestBufferSize","byteLength","locks","request","playAudio","readAsArrayBuffer","stop","getTracks","forEach","track","close","int16Array","float32Array","Float32Array","audioBuffer","createBuffer","set","createBufferSource","bufferDuration","currentTime","start","onsubmit","ev","preventDefault","state","resume","AudioContext","Uint8Array"],"version":3,"file":"index.44203d75.js.map"}